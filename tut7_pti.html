<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CARLsim: Tutorial 7: Parameter Tuning Interface (PTI)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="CARLsimStyles.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CARLsim
   &#160;<span id="projectnumber">6.0.0</span>
   </div>
   <div id="projectbrief">CARLsim: a GPU-accelerated SNN simulator</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tut7_pti.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Tutorial 7: Parameter Tuning Interface (<a class="el" href="classPTI.html">PTI</a>) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#tut7s1_intro">7.1 Introduction</a></li>
<li class="level1"><a href="#tut7s2_experiment_class">7.2 Wrapping the Simulation</a><ul><li class="level2"><a href="#tut7s2a_main">The Main Method</a></li>
<li class="level2"><a href="#tut7s2b_experiment">The Experiment Class</a></li>
</ul>
</li>
<li class="level1"><a href="#tut7s3_parameter_file">7.3 The ECJ Parameter File</a><ul><li class="level2"><a href="#tut7s3a_boiler">Boiler Plate</a></li>
<li class="level2"><a href="#Problem">Problem</a></li>
<li class="level2"><a href="#Population">Population</a></li>
<li class="level2"><a href="#Representation">Representation</a></li>
<li class="level2"><a href="#Operators">Operators</a></li>
<li class="level2"><a href="#Logging">Logging</a></li>
<li class="level2"><a href="#ECJ">Output</a></li>
</ul>
</li>
<li class="level1"><a href="#tut7s4_leap">7.4 The LEAP Configuration File</a></li>
<li class="level1"><a href="#tut7s5_references">References</a></li>
</ul>
</div>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>Eric O. Scott </dd>
<dd>
Kristofor D. Carlson </dd>
<dd>
Kexin Chen</dd></dl>
<h1><a class="anchor" id="tut7s1_intro"></a>
7.1 Introduction</h1>
<p>In this tutorial we introduce <a class="el" href="classCARLsim.html" title="CARLsim User Interface This class provides a user interface to the public sections of CARLsimCore sou...">CARLsim</a>'s auxiliary <b>parameter-tuning interface</b> and how to tune the weight ranges of a simple <a class="el" href="classSNN.html" title="Contains all of CARLsim&#39;s core functionality. ">SNN</a> to achieve a particular target firing rate. We will be tuning four parameter values that represent the weight ranges. Here we show how to optimize the model with an <b>evolutionary algorithm</b> (EA). We provide one example of using <a href="https://cs.gmu.edu/~eclab/projects/ecj/">ECJ evolutionary computation framework</a>, and one example of using <a href="https://github.com/AureumChaos/LEAP">LEAP evolutionary computation package</a>.</p>
<p>We will accomplish this by <b>wrapping</b> our <a class="el" href="classCARLsim.html" title="CARLsim User Interface This class provides a user interface to the public sections of CARLsimCore sou...">CARLsim</a> model inside a program that accepts parameter values on <code>stdin</code>, runs the model, and then writes fitness values to <code>stdout</code>. For example, once we've compiled this model, we can pipe one or more comma-delimited vector of parameters staright into it, and a fitness value will be returned (or multiple values, if we send multiple vectors):</p>
<div class="fragment"><div class="line">$ echo <span class="stringliteral">&quot;0.1,0.1,0.1,0.1&quot;</span> | ./TuneFiringRates</div><div class="line">0.000690975</div></div><!-- fragment --><p>This provides an interface that allows your <a class="el" href="classCARLsim.html" title="CARLsim User Interface This class provides a user interface to the public sections of CARLsimCore sou...">CARLsim</a> model to be tuned by external optimization tools such as ECJ or LEAP, or by your own parameter sweep scripts, etc.</p>
<p>All the required files for the example we describe here are found in the <code>doc/source/tutorial/7_pti/src/</code> directory. We encourage you to follow along and experiment with the source code found there!</p>
<p>This tutorial assumes:</p><ul>
<li>ECJ version 28 or greater is installed. Find it at <a href="https://cs.gmu.edu/~eclab/projects/ecj/">https://cs.gmu.edu/~eclab/projects/ecj/</a></li>
<li>LEAP is installed. Find it at <a href="https://github.com/AureumChaos/LEAP">https://github.com/AureumChaos/LEAP</a>.</li>
<li><a class="el" href="classCARLsim.html" title="CARLsim User Interface This class provides a user interface to the public sections of CARLsimCore sou...">CARLsim</a> 6.0 is installed.</li>
</ul>
<p>ECJ/ LEAP handles all steps of the EA except for <em>fitness</em> <em>evaluation</em>, which is done by <a class="el" href="classCARLsim.html" title="CARLsim User Interface This class provides a user interface to the public sections of CARLsimCore sou...">CARLsim</a> through the implementation of an <code><a class="el" href="classExperiment.html">Experiment</a></code> class function called <code>run</code>.</p>
<div class="image">
<img src="ECJ-Loop.png" alt="ECJ-Loop.png"/>
<div class="caption">
A general approach to parameter tuning. ECJ performs uses an EA to generate candidate parameter configurations, and passes the current generation of parameters (red arrow) to CARLsim for evaluation using the parameter tuning interface (PTI) code. CARLsim assigns each parameter set to an SNN and evaluates all the individuals in parallel, passing the fitness values back to ECJ for selection of individuals in the next generation (black arrow).</div></div>
<p> Source: Beyeler et al., 2015</p>
<h1><a class="anchor" id="tut7s2_experiment_class"></a>
7.2 Wrapping the Simulation</h1>
<p>Let's begin by building our <a class="el" href="classCARLsim.html" title="CARLsim User Interface This class provides a user interface to the public sections of CARLsimCore sou...">CARLsim</a> model and fitness function. The full example is found in <code>main_TuneFiringRates.cpp</code>. You can use it as a template for implementing your own parameter-tuning experiments.</p>
<p>We'll do three things a little differently from the previous tutorials:</p>
<ol type="1">
<li>we'll wrap our model in a CLI that accepts parameters on <code>stdin</code>,</li>
<li>we'll use the <code><a class="el" href="classParameterInstances.html">ParameterInstances</a></code> class to handles parsing the input parameters and plug them into our model, and</li>
<li>after the model runs, we'll write a fitness value to <code>stdout</code> for each parameter instance we received.</li>
</ol>
<h2><a class="anchor" id="tut7s2a_main"></a>
The Main Method</h2>
<p>For the high-level entrypoint in <code>main()</code>, we'll start by including <a class="el" href="classCARLsim.html" title="CARLsim User Interface This class provides a user interface to the public sections of CARLsimCore sou...">CARLsim</a> and <code><a class="el" href="PTI_8h.html">PTI.h</a></code>. The latter cointains some high-level code that helps us standardize our parameter-tuning interface across projects (namely the <code><a class="el" href="classExperiment.html">Experiment</a></code> and <code><a class="el" href="classPTI.html">PTI</a></code> classes).</p>
<p>Then we'll begin by loading a couple of CLI parameters. The <code>verbosity</code> parameter in particular will allow us to write <a class="el" href="classCARLsim.html" title="CARLsim User Interface This class provides a user interface to the public sections of CARLsimCore sou...">CARLsim</a> logs to stdout while we're debugging our model, but to keep them silent while tuning (so only fitness values are written to <code>stdout</code>). We're using a simple helper function <code>hasOpt()</code> for this (find it in the full source file):</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="PTI_8h.html">PTI.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="carlsim_8h.html">carlsim.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[]) {</div><div class="line">    <span class="comment">/* First we Initialize an Experiment and a PTI object.  The PTI parses CLI</span></div><div class="line"><span class="comment">    * arguments, and then loads the Parameters from a file (if one has been</span></div><div class="line"><span class="comment">    * specified by the user) or else from a default istream (std::cin here). */</span></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="carlsim__datastructures_8h.html#a625c4eced5cd956404990e73f3950258">SimMode</a> simMode = hasOpt(argc, argv, <span class="stringliteral">&quot;cpu&quot;</span>) ? <a class="code" href="carlsim__datastructures_8h.html#a625c4eced5cd956404990e73f3950258a729ca642c452f8a7c53df4a48f240537">CPU_MODE</a> : <a class="code" href="carlsim__datastructures_8h.html#a625c4eced5cd956404990e73f3950258a0b5ee5e90bb225a562d92e4078ad9728">GPU_MODE</a>;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="carlsim__datastructures_8h.html#a3a04fc42e22f436d2b3809236cb6ec54">LoggerMode</a> verbosity = hasOpt(argc, argv, <span class="stringliteral">&quot;v&quot;</span>) ? <a class="code" href="carlsim__datastructures_8h.html#a3a04fc42e22f436d2b3809236cb6ec54ae2d30a195cee6b2961cc2c23ea4b520b">USER</a> : <a class="code" href="carlsim__datastructures_8h.html#a3a04fc42e22f436d2b3809236cb6ec54ab9de27525b1cd54c353f4ed868a6cb26">SILENT</a>;</div></div><!-- fragment --><p> Next, we'll instantiate our model. We'll write the implementation of <code>TunefiringRatesExperiment</code> class in a moment below:</p>
<div class="fragment"><div class="line">    <span class="keyword">const</span> TuneFiringRatesExperiment experiment(simMode, verbosity);</div></div><!-- fragment --><p> To execute the model, we'll use the <code><a class="el" href="classPTI.html">PTI</a></code> class. This is a simple class that orchestrates the loading of parameters from an input stream (usually <code>std::cin</code>), uses them to execute your <code><a class="el" href="classExperiment.html">Experiment</a></code> subclass, and collects the results to an output stream (<code>std::cout</code>).</p>
<div class="fragment"><div class="line">    <span class="keyword">const</span> <a class="code" href="classPTI.html">PTI</a> pti(argc, argv, std::cout, std::cin);</div><div class="line"></div><div class="line">    <span class="comment">/* The PTI will now cheerfully iterate through all the Parameter sets and</span></div><div class="line"><span class="comment">    * run your Experiment on it, printing the results to the specified</span></div><div class="line"><span class="comment">    * ostream (std::cout here). */</span></div><div class="line">    pti.runExperiment(experiment);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="tut7s2b_experiment"></a>
The Experiment Class</h2>
<p>Now, at the top of the same file, we'll implement the <code>TuneFiringRatesExperiment</code> class that our <code>main()</code> uses.</p>
<p>The layout of the <a class="el" href="classSNN.html" title="Contains all of CARLsim&#39;s core functionality. ">SNN</a> is as follows. We have a three groups of neurons, each configured to have <code>NUM_NEURONS_PER_GROUP = 100</code> neurons:</p>
<ol type="1">
<li>a group <code>poisson</code> of excitatory, Poisson-spiking input neurons,</li>
<li>a group <code>exc</code> of excitatory regular-spiking (RS) neurons that receive this input, and</li>
<li>a group <code>inh</code> of inhibitory fast-spiking (FS) izhikevich neurons that receive input from the excitatory RS neurons.</li>
</ol>
<p>Additionally, <code>inh</code> is connected to the RS <code>exh</code> group, and <code>exh</code> is connected to itself recurrently. There are therefore 4 connection weight ranges to be tuned</p>
<div class="image">
<img src="Network_groups.png" alt="Network_groups.png"/>
<div class="caption">
Fig. 1. Structure of our SNN. It's made of up 3 groups with a total of 4 sets of connections.</div></div>
<p>The <b>goal of the our parameter-tuning problem</b> is to make the RS <code>exc</code> group have an average firing rate of 10 Hz and make the FS <code>inh</code> group have an average firing rate of 20 Hz.</p>
<p>First we'll inhereit from the <code><a class="el" href="classExperiment.html">Experiment</a></code> base class and define some constants used by our model. This makes it possible to pass our model into into a <code>pti.runExperiment()</code> call:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>TuneFiringRatesExperiment : <span class="keyword">public</span> <a class="code" href="classExperiment.html">Experiment</a> {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// Various constants are defined here at the top that we&#39;ll use  later on</span></div></div><!-- fragment --><p> For our constructor, we'll just pull in two parameters to define whether we're using a CPU or GPU, and what level of logging to use.</p>
<div class="fragment"><div class="line">    <span class="keyword">const</span> <a class="code" href="carlsim__datastructures_8h.html#a3a04fc42e22f436d2b3809236cb6ec54">LoggerMode</a> verbosity;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="carlsim__datastructures_8h.html#a625c4eced5cd956404990e73f3950258">SimMode</a> simMode;</div><div class="line"></div><div class="line">    TuneFiringRatesExperiment(<span class="keyword">const</span> <a class="code" href="carlsim__datastructures_8h.html#a625c4eced5cd956404990e73f3950258">SimMode</a> simMode, <span class="keyword">const</span> <a class="code" href="carlsim__datastructures_8h.html#a3a04fc42e22f436d2b3809236cb6ec54">LoggerMode</a> verbosity): simMode(simMode), verbosity(verbosity) {}</div></div><!-- fragment --><p> Now we'll implement the <code>run()</code> method, which handles the simulation meat and acts as the fitness function for optimization.</p>
<div class="fragment"><div class="line">    <span class="keywordtype">void</span> run(<span class="keyword">const</span> <a class="code" href="classParameterInstances.html">ParameterInstances</a> &amp;parameters, std::ostream &amp;outputStream)<span class="keyword"> const </span>{</div><div class="line"></div><div class="line">        <span class="comment">// Construct a CARLsim network on the heap.</span></div><div class="line">        <a class="code" href="classCARLsim.html">CARLsim</a>* <span class="keyword">const</span> network = <span class="keyword">new</span> <a class="code" href="classCARLsim.html">CARLsim</a>(<span class="stringliteral">&quot;tuneFiringRates&quot;</span>, simMode, verbosity);</div></div><!-- fragment --><p> Now we are going to build many neural networks at the same time within a single <code><a class="el" href="classCARLsim.html" title="CARLsim User Interface This class provides a user interface to the public sections of CARLsimCore sou...">CARLsim</a></code> instance&mdash;one for each of the parameter vectors in the <code><a class="el" href="classParameterInstances.html">ParameterInstances</a></code>. Doing this allows us to evaluate several separate networks at once on a GPU.</p>
<p>We'll start by seting up <code><a class="el" href="classSpikeMonitor.html" title="Class SpikeMonitor. ">SpikeMonitor</a></code>s and variables to track the neuron groups for each individual's network:</p>
<div class="fragment"><div class="line">        <span class="comment">// Define constant Izhikevich parameters for two types of neurons</span></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> REG_IZH[] = { 0.02f, 0.2f, -65.0f, 8.0f };</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> FAST_IZH[] = { 0.1f, 0.2f, -65.0f, 2.0f };</div><div class="line"></div><div class="line">        <span class="comment">// The number of individuals (separate parameter configurations) we have received</span></div><div class="line">        <span class="keywordtype">int</span> indiNum = parameters.<a class="code" href="classParameterInstances.html#ac03921debef2a267dfc292209cfe099e">getNumInstances</a>();</div><div class="line"></div><div class="line">        <span class="comment">// Groups for each individual</span></div><div class="line">        <span class="keywordtype">int</span> poissonGroup[indiNum];</div><div class="line">        <span class="keywordtype">int</span> excGroup[indiNum];</div><div class="line">        <span class="keywordtype">int</span> inhGroup[indiNum];</div><div class="line"></div><div class="line">        <span class="comment">// Measure spiking activity on each exc and inh group</span></div><div class="line">        <a class="code" href="classSpikeMonitor.html">SpikeMonitor</a>* excMonitor[indiNum];</div><div class="line">        <a class="code" href="classSpikeMonitor.html">SpikeMonitor</a>* inhMonitor[indiNum];</div></div><!-- fragment --><p> We'll also set up some more arrays to track the firing rates of each network, and the fitness values that we'll calculate from those firing rates:</p>
<div class="fragment"><div class="line">        <span class="comment">// We&#39;ll process the spiking activity into a fitness value</span></div><div class="line">        <span class="keywordtype">float</span> excHz[indiNum];</div><div class="line">        <span class="keywordtype">float</span> inhHz[indiNum];</div><div class="line">        <span class="keywordtype">float</span> excError[indiNum];</div><div class="line">        <span class="keywordtype">float</span> inhError[indiNum];</div><div class="line">        <span class="keywordtype">float</span> fitness[indiNum];</div></div><!-- fragment --><p> Now we'll set up the actual groups for each network. This involves iterating through all of the <code><a class="el" href="classParameterInstances.html">ParameterInstances</a></code> that we have been given, and using their values to set certain parameters of our network. These are the values that will be tuned to maximize our measure of fitness:</p>
<div class="fragment"><div class="line">        <span class="comment">// We&#39;ll add groups for *all* the individuals to the same large CARLsim network object.</span></div><div class="line">        <span class="comment">// This allows us to run multiple networks side-by-side on the same GPU: we treat them as</span></div><div class="line">        <span class="comment">// a single mega-network with many non-interacting components.</span></div><div class="line">        assert(parameters.<a class="code" href="classParameterInstances.html#affbaabab6d7c9a29bf8e43665a3f16c2">getNumParameters</a>() &gt;= 4);</div><div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; parameters.<a class="code" href="classParameterInstances.html#ac03921debef2a267dfc292209cfe099e">getNumInstances</a>(); i++) {</div><div class="line">            poissonGroup[i] = network-&gt;<a class="code" href="classCARLsim.html#a0bf4d12b0b90740faf9a2f6a4add0351">createSpikeGeneratorGroup</a>(<span class="stringliteral">&quot;poisson&quot;</span>, NUM_NEURONS_PER_GROUP, <a class="code" href="carlsim__definitions_8h.html#a71b1b059a7ff0783d39e22b9b1028d90">EXCITATORY_NEURON</a>);</div><div class="line">            excGroup[i] = network-&gt;<a class="code" href="classCARLsim.html#a6e11c10b6b079715074d857452c42e11">createGroup</a>(<span class="stringliteral">&quot;exc&quot;</span>, NUM_NEURONS_PER_GROUP, <a class="code" href="carlsim__definitions_8h.html#a71b1b059a7ff0783d39e22b9b1028d90">EXCITATORY_NEURON</a>);</div><div class="line">            inhGroup[i] = network-&gt;<a class="code" href="classCARLsim.html#a6e11c10b6b079715074d857452c42e11">createGroup</a>(<span class="stringliteral">&quot;inh&quot;</span>, NUM_NEURONS_PER_GROUP, <a class="code" href="carlsim__definitions_8h.html#a1f1973192224715d2362de045a5c6387">INHIBITORY_NEURON</a>);</div><div class="line"></div><div class="line">            network-&gt;<a class="code" href="classCARLsim.html#aa6e1dc5ae50722ae3d693f2c963d84cd">setNeuronParameters</a>(excGroup[i], REG_IZH[0], REG_IZH[1], REG_IZH[2], REG_IZH[3]);</div><div class="line">            network-&gt;<a class="code" href="classCARLsim.html#aa6e1dc5ae50722ae3d693f2c963d84cd">setNeuronParameters</a>(inhGroup[i], FAST_IZH[0], FAST_IZH[1], FAST_IZH[2], FAST_IZH[3]);</div><div class="line">            network-&gt;<a class="code" href="classCARLsim.html#a580acd7bfec3145c00014b0bd1742e2e">setConductances</a>(<span class="keyword">true</span>,COND_tAMPA,COND_tNMDA,COND_tGABAa,COND_tGABAb);</div><div class="line"></div><div class="line">            network-&gt;<a class="code" href="classCARLsim.html#a30b16b93d57551dcde0559e8a4e98e27">connect</a>(poissonGroup[i], excGroup[i], <span class="stringliteral">&quot;random&quot;</span>, <a class="code" href="structRangeWeight.html">RangeWeight</a>(parameters.<a class="code" href="classParameterInstances.html#a4b0f3b5fa03252eabce3894973d30460">getParameter</a>(i,0)), 0.5f, <a class="code" href="structRangeDelay.html">RangeDelay</a>(1));</div><div class="line">            network-&gt;<a class="code" href="classCARLsim.html#a30b16b93d57551dcde0559e8a4e98e27">connect</a>(excGroup[i], excGroup[i], <span class="stringliteral">&quot;random&quot;</span>, <a class="code" href="structRangeWeight.html">RangeWeight</a>(parameters.<a class="code" href="classParameterInstances.html#a4b0f3b5fa03252eabce3894973d30460">getParameter</a>(i,1)), 0.5f, <a class="code" href="structRangeDelay.html">RangeDelay</a>(1));</div><div class="line">            network-&gt;<a class="code" href="classCARLsim.html#a30b16b93d57551dcde0559e8a4e98e27">connect</a>(excGroup[i], inhGroup[i], <span class="stringliteral">&quot;random&quot;</span>, <a class="code" href="structRangeWeight.html">RangeWeight</a>(parameters.<a class="code" href="classParameterInstances.html#a4b0f3b5fa03252eabce3894973d30460">getParameter</a>(i,2)), 0.5f, <a class="code" href="structRangeDelay.html">RangeDelay</a>(1));</div><div class="line">            network-&gt;<a class="code" href="classCARLsim.html#a30b16b93d57551dcde0559e8a4e98e27">connect</a>(inhGroup[i], excGroup[i], <span class="stringliteral">&quot;random&quot;</span>, <a class="code" href="structRangeWeight.html">RangeWeight</a>(parameters.<a class="code" href="classParameterInstances.html#a4b0f3b5fa03252eabce3894973d30460">getParameter</a>(i,3)), 0.5f, <a class="code" href="structRangeDelay.html">RangeDelay</a>(1));</div><div class="line">        }</div></div><!-- fragment --><p> Now we need to pause and compile the networks before attaching the monitors:</p>
<div class="fragment"><div class="line">        <span class="comment">// With all the groups and connections specified, we can now setup the mega-network</span></div><div class="line">        network-&gt;<a class="code" href="classCARLsim.html#a6d6c298c788eeb7b18a19d82a77761b3">setupNetwork</a>();</div></div><!-- fragment --><p> Now we'll hop back into a <code>for</code> loop to add the monitors:</p>
<div class="fragment"><div class="line">        <span class="comment">// Configure the spiking rate for the Poisson inputs</span></div><div class="line">        <a class="code" href="classPoissonRate.html">PoissonRate</a>* <span class="keyword">const</span> in = <span class="keyword">new</span> <a class="code" href="classPoissonRate.html">PoissonRate</a>(NUM_NEURONS_PER_GROUP);</div><div class="line">        in-&gt;<a class="code" href="classPoissonRate.html#a39ade841ecc17249712f693ef8ffaa19">setRates</a>(INPUT_TARGET_HZ);</div><div class="line"></div><div class="line">        <span class="comment">// Assign the spiking rate and spikeMonitors for each sub-network</span></div><div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; parameters.<a class="code" href="classParameterInstances.html#ac03921debef2a267dfc292209cfe099e">getNumInstances</a>(); i++) {</div><div class="line">            network-&gt;<a class="code" href="classCARLsim.html#a04f52d2840105c8ccacf8d378d1695cf">setSpikeRate</a>(poissonGroup[i],in);</div><div class="line"></div><div class="line">            excMonitor[i] = network-&gt;<a class="code" href="classCARLsim.html#a1e0b4d170b65f5075f1a996554c842ab">setSpikeMonitor</a>(excGroup[i], <span class="stringliteral">&quot;/dev/null&quot;</span>);</div><div class="line">            inhMonitor[i] = network-&gt;<a class="code" href="classCARLsim.html#a1e0b4d170b65f5075f1a996554c842ab">setSpikeMonitor</a>(inhGroup[i], <span class="stringliteral">&quot;/dev/null&quot;</span>);</div><div class="line"></div><div class="line">            excMonitor[i]-&gt;<a class="code" href="classSpikeMonitor.html#ab91616c118b701c2afd9136393d1f19b">startRecording</a>();</div><div class="line">            inhMonitor[i]-&gt;<a class="code" href="classSpikeMonitor.html#ab91616c118b701c2afd9136393d1f19b">startRecording</a>();</div><div class="line"></div><div class="line">            <span class="comment">// initialize all the error and fitness variables</span></div><div class="line">            excHz[i]=0; inhHz[i]=0;</div><div class="line">            excError[i]=0; inhError[i]=0;</div><div class="line">            fitness[i]=0;</div><div class="line">        }</div></div><!-- fragment --><p> Now we can execute the networks:</p>
<div class="fragment"><div class="line">        <span class="comment">// GO!</span></div><div class="line">        network-&gt;<a class="code" href="classCARLsim.html#aafb2d44405c96aafe089f96ff867018d">runNetwork</a>(runTime,0);</div></div><!-- fragment --><p> After the simulation is complete, we can loop back through and compute fitness values for each network.</p>
<p>The fitness function can be whatever you need it to be to solve your problem: just compute a number and write it to the <code>outputstream</code> variable that is passed into the <code>run()</code> method.</p>
<p>In this tutorial, we compute fitness based on the difference between each group's mean firing rate and our target firing rate. We want our fitness function to define a maximization problem, where higher values are better (because ECJ expects to be given maximization problems). To achieve this, we sum the errors for each group and then take the reciprocal:</p>
<div class="fragment"><div class="line">        <span class="comment">// For each sub-network, extract the mean firing rate and compute a fitness value based on its difference from the target rate</span></div><div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; parameters.<a class="code" href="classParameterInstances.html#ac03921debef2a267dfc292209cfe099e">getNumInstances</a>(); i++) {</div><div class="line"></div><div class="line">            excMonitor[i]-&gt;<a class="code" href="classSpikeMonitor.html#a25e0e98dd4519eaaa6b258f0dcb91ac7">stopRecording</a>();</div><div class="line">            inhMonitor[i]-&gt;<a class="code" href="classSpikeMonitor.html#a25e0e98dd4519eaaa6b258f0dcb91ac7">stopRecording</a>();</div><div class="line"></div><div class="line">            excHz[i] = excMonitor[i]-&gt;<a class="code" href="classSpikeMonitor.html#ae62d623e8edfc6b05309256c1d825bbd">getPopMeanFiringRate</a>();</div><div class="line">            inhHz[i] = inhMonitor[i]-&gt;<a class="code" href="classSpikeMonitor.html#ae62d623e8edfc6b05309256c1d825bbd">getPopMeanFiringRate</a>();</div><div class="line"></div><div class="line">            excError[i] = fabs(excHz[i] - EXC_TARGET_HZ);</div><div class="line">            inhError[i] = fabs(inhHz[i] - INH_TARGET_HZ);</div><div class="line"></div><div class="line">            fitness[i] = 1/(excError[i] + inhError[i]);</div><div class="line">            outputStream &lt;&lt; fitness[i] &lt;&lt; endl;</div><div class="line">        }</div></div><!-- fragment --><p> Lastly, we'll close our <code><a class="el" href="classExperiment.html">Experiment</a></code> with some cleanup, since we didn't use smart pointers:</p>
<div class="fragment"><div class="line">        <span class="keyword">delete</span> network;</div><div class="line">        <span class="keyword">delete</span> in;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div></div><!-- fragment --><p> All done. Compiling <code>main_TuneFiringRates.cpp</code> yields a program <code>TuneFiringRates</code> that takes comma-delimited parameter vectors on <code>std::cin</code> and outputs fitness values. </p><div class="fragment"><div class="line">mkdir .build</div><div class="line">cd .build</div><div class="line">cmake ..</div><div class="line">make</div></div><!-- fragment --><h1><a class="anchor" id="tut7s3_parameter_file"></a>
7.3 The ECJ Parameter File</h1>
<p>The other piece of the puzzle is the optimization algorithm. You can use anything you want to search the model's parameter space, but ECJ and <a class="el" href="classCARLsim.html" title="CARLsim User Interface This class provides a user interface to the public sections of CARLsimCore sou...">CARLsim</a> are specifically built to work together. ECJ offers a wide variety of evolutionary algorithms that can be used to tune complex, nonlinear parameter spaces.</p>
<p>We'll configure ECJ to optimize our model's parameter's with a simple evolutionary algorithm. To do so, we'll write a <b>parameter file.</b></p>
<p>ECJ uses big, centralized parameter files to coordinate the interaction of a number of different algorithmic modules, traditionally ending with the extension <code>.params</code> (though they are in fact Java <code>.properties</code> files). In this example, we'll implement a (μ, λ)-style evolutionary algorithm (i.e., an algorithm that discards the parents at each generation) that evolves real-valued parameter vectors with Gaussian mutation of each real-valued gene, one-point crossover, and truncation selection. You can find the complete example in <code>ecj_TuneFiringRates.params</code>.</p>
<p>The <b><a href="https://cs.gmu.edu/~eclab/projects/ecj/manual.pdf">ECJ manual</a></b> is a great resource for undertstanding these parameters and how to configure them in more detail.</p>
<h2><a class="anchor" id="tut7s3a_boiler"></a>
Boiler Plate</h2>
<p>Create a new <code>.params</code> file and open it with an editor. We'll start by inheriting some boiler-plate parameters from a parent file at the top of our file:</p>
<div class="fragment"><div class="line">parent.0 =                                      ./ecj_boiler_plate.params</div></div><!-- fragment --><p>The <code>ecj_boiler_plate</code> file contains quite a few standard parameter settings that we typically only alter in special circumstances—it defines things like the Java classes that manage the algorithm and population state.</p>
<h2><a class="anchor" id="Problem"></a>
Problem</h2>
<p>Next, and most importantly, we want to tell ECJ to use an external binary program to compute fitness. This is done by configuring the <code>problem</code> parameter to point to the <code>CommandProblem</code> class. This is a special ECJ fitness function that writes parameters to a program's <code>std::cin</code> and reads fitness values back that your model writes to <code>std::cout</code>.</p>
<p>While we're at it we'll also define <code>evalthreads</code>, which controls how many instances of your model program will be run in parallel. In this tutorial we're relying on the internal parallelism of a single <a class="el" href="classCARLsim.html" title="CARLsim User Interface This class provides a user interface to the public sections of CARLsimCore sou...">CARLsim</a> instance to evaluate many individuals at once, so we'll leave ECJ's <code>evalthreads</code> set to 1.</p>
<div class="fragment"><div class="line">eval.problem =                                  ec.app.command.CommandProblem</div><div class="line">eval.problem.command =                          ./.build/TuneFiringRates</div><div class="line">evalthreads =                                   1</div></div><!-- fragment --><h2><a class="anchor" id="Population"></a>
Population</h2>
<p>The next important group of parameters controls the population and the outline of how it evolves. Here we specify that we want a maximum number of 50 generations. The <code>quit-on-run-complete</code> parameter toggles whether or not evolution should stop early if a solution with the "ideal" fitness is found. We are tuning a noisy fitness function, however, which sometimes causes an individual to momentarily appear to have a high fitness by chance—and we don't want to stop early when that happens.</p>
<div class="fragment"><div class="line">generations =                                   50</div><div class="line">quit-on-run-complete =                          <span class="keyword">false</span></div></div><!-- fragment --><p>Now we'll tell ECJ to generate 20 individuals to populate the initial population (i.e. the very first generation, when individuals are generated randomly). It's sometimes a good idea to create many individuals in the first generation, because this gives us a chance to find a good starting point with random search, before we use evolution to refine it. After that, a (μ, λ) breeder takes over evolution, generating <code>es.lamda.0</code> children and selecting <code>es.mu.0</code> parents at each generation (the <code>*.0</code> at the end of these parameter names refers to the settings for the "zeroeth subpopulation"; since we're using a single-population algorithm, this is the only subpopulation).</p>
<div class="fragment"><div class="line">pop.subpop.0.size =                             20</div><div class="line">breed =                                         ec.es.MuCommaLambdaBreeder</div><div class="line">es.mu.0 =                                       10</div><div class="line">es.lambda.0 =                                   20</div></div><!-- fragment --><p>ECJ has several other breeding strategies available, including a (μ + λ) breeder (<code>ec.es.MuPlusLambdaBreeder</code>), which treats parents and offspring as a combined population (so parents have a chance of surviving multiple generations), and <code>ec.simple.SimpleBreeder</code> (which is like <code>MuCommaLambdaBreeder</code>, but is meant to work with other traditional selection methods, such as tournament selection).</p>
<h2><a class="anchor" id="Representation"></a>
Representation</h2>
<p>Now we'll add several parameters to define how solutions are represented in the EA. The first three are pretty standard, specifying that we want to use floating-point vectors of numbers:</p>
<div class="fragment"><div class="line">pop.subpop.0.species =                          ec.vector.FloatVectorSpecies</div><div class="line">pop.subpop.0.species.ind =                      ec.vector.DoubleVectorIndividual</div><div class="line">pop.subpop.0.species.fitness =                  ec.simple.SimpleFitness</div></div><!-- fragment --><p>Now specify the numer of genes each individual should have, and the ranges within which they should be initialized. Our model has four parameters to tune, so we'll want four genes:</p>
<div class="fragment"><div class="line">pop.subpop.0.species.genome-size =      4</div><div class="line">pop.subpop.0.species.min-gene =         0.0005</div><div class="line">pop.subpop.0.species.max-gene =         0.5</div></div><!-- fragment --><p>In this case we've configured all four parameters so that they share the same parameter range (0.0005, 0.5)—but each individual parameter can be given it's own range if need be (see the discussion of ECJ's "segments" mechanism in the <b><a href="https://cs.gmu.edu/~eclab/projects/ecj/manual.pdf">ECJ manual</a></b>).</p>
<h2><a class="anchor" id="Operators"></a>
Operators</h2>
<p>The last algorithmic component we need to configure are the operators. These define how new individuals are created in each generation, and how parents are selected from the previous generation.</p>
<p>In ECJ, we add operators by stringing together "pipelines," each of which takes one or more <code>source</code> parameters. The following entries specify a pipeline that generates individuals via a mutation pipeline, taking its inputs from a crossover pipeline, which in turn receives individuals (in pairs) from an <code>ESSelection</code> operator. <code>ESSelection</code> performs truncation selection (i.e. it deterministically chooses the best individuals in the population). When the algorithm runs, <code>ESSelection</code> is applied first to the parent population, and mutation occurs last:</p>
<div class="fragment"><div class="line">pop.subpop.0.species.pipe =                     ec.vector.breed.VectorMutationPipeline</div><div class="line">pop.subpop.0.species.pipe.source.0 =            ec.vector.breed.VectorCrossoverPipeline</div><div class="line">pop.subpop.0.species.pipe.source.0.source.0 =   ec.es.ESSelection</div><div class="line">pop.subpop.0.species.pipe.source.0.source.1 =   ec.es.ESSelection</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The <code>ESSelection</code> operator and the <code>MuCommaLambdaBreeder</code> (or, alternatively, <code>MuCommaPlusBreeder</code>) belong to ECJ's <em>evolution</em> <em>strategies</em> package, <code>ecj.es</code>, and are inteded to be used together. You cannot use <code>ESSelection</code> without one of these breeders, because they perform special bookeeping needed for elitist selection to work. Likewise, if you want to use other (less elitist) selection operators such as <code>TournamentSelection</code>, you may prefer to use ECJ's standard <code>SimpleBreeder</code> instead of these more complex breeders. See the <a href="https://cs.gmu.edu/~eclab/projects/ecj/manual.pdf">ECJ manual</a> for more information.</dd></dl>
<p>With the high-level pipeline in place, now we'll add parameters for the individual operators. The first set informs <code>VectorMutationPipeline</code> that we want to use additive Gaussian mutation, that we want mutation to be "bounded" (so that gene values cannot wander outside of their initial allowed range of 0.0005–0.5), and that we will always mutate every gene (probability 1.0) and use a mutation width (Gaussian standard deviation) of 0.5:</p>
<div class="fragment"><div class="line">pop.subpop.0.species.mutation-type =            gauss</div><div class="line">pop.subpop.0.species.mutation-bounded =         <span class="keyword">true</span></div><div class="line">pop.subpop.0.species.mutation-prob =            1.0</div><div class="line">pop.subpop.0.species.mutation-stdev =           0.5</div></div><!-- fragment --><p>Next we'll define the crossover strategy, here choosing one-point crossover (which chooses one point to split individuals at when performing genetic recombination):</p>
<div class="fragment"><div class="line">pop.subpop.0.species.crossover-type =           one</div></div><!-- fragment --><p>The selection operator <code>ESSelection</code> does not require any parameters, but if you use other operators (such as the popular <code>TournamentSelection</code>) they may have parameters of their own that you should also set.</p>
<h2><a class="anchor" id="Logging"></a>
Logging</h2>
<p>By default, ECJ writes some information about the best individual found at each generation to <code>stdout</code>. If we want more information that this, we'll typically write it to a file. These two lines activate one of ECJ's statistics collection modules (<code>SimpleStatistics</code>) and point it to write to the file <code>./out.stat</code> in the current directory.</p>
<div class="fragment"><div class="line">stat =                                          ec.simple.SimpleStatistics</div><div class="line">stat.file =                                     $out.stat</div></div><!-- fragment --><p>Notice there is a <code>$</code> in the output filename. This indicates that the output path an "execution-relative" path, i.e. it is relative to the working directory that the ECJ process was launched from (rather than relative to the parameter file we are writing). The different types of paths ECJ supporst are explained in the ECJ Manual.</p>
<h2><a class="anchor" id="ECJ"></a>
Output</h2>
<p>With our model compiled and our parameter file complete, we can tune the model by using the <code>java</code> command to run ECJ, passing in our parameter file to its <code>-file</code> argument:</p>
<div class="fragment"><div class="line">java -jar ~/path/to/ecj/ecj-28.jar -file ./ecj_TuneFiringRates.params</div></div><!-- fragment --><p>The simulation should run to completion and output the best fitness each generation.</p>
<p>An <code>out.stat</code> file should also appear in the current working directory, since we configured the <code>stat</code> parameter to create it there. This will contains the best fitness for each generation along with the four parameter values associated with the individual. <a class="el" href="classCARLsim.html" title="CARLsim User Interface This class provides a user interface to the public sections of CARLsimCore sou...">CARLsim</a> users can then use these parameters for their tuned <a class="el" href="classSNN.html" title="Contains all of CARLsim&#39;s core functionality. ">SNN</a> models.</p>
<dl class="section since"><dt>Since</dt><dd>v3.0</dd></dl>
<h1><a class="anchor" id="tut7s4_leap"></a>
7.4 The LEAP Configuration File</h1>
<p>Similar to using ECJ, we can also use LEAP to tune the network. A complete example can be found in <code>leap_TuneFiringRates.params</code>.</p>
<p>First we define the size of the population, the number of genes, and the maximum number of generations. </p><div class="fragment"><div class="line">pop_size = 20</div><div class="line">num_genes = 4</div><div class="line">generations = 50</div></div><!-- fragment --><p>We then want to tell LEAP to evaluate an external problem, which launches the program that contains our network simulation. </p><div class="fragment"><div class="line">problem = ExternalProcessProblem(command=<span class="stringliteral">&#39;./.build/TuneFiringRates&#39;</span>, maximize=True)</div></div><!-- fragment --><p>We launch the evolutionary algorithm by calling the function <code>generational_ea(...)</code>. </p><div class="fragment"><div class="line">ea = generational_ea(max_generations=generations, pop_size=pop_size,</div><div class="line">                            problem=problem,  # Fitness <span class="keyword">function</span></div><div class="line">                            </div><div class="line">                            # By <span class="keywordflow">default</span>, the initial population would be evaluated one-at-a-time.</div><div class="line">                            # Passing group_evaluate into init_evaluate evaluates the population in batches.</div><div class="line">                            init_evaluate=ops.grouped_evaluate(problem=problem, max_individuals_per_chunk=max_individuals_per_chunk),</div><div class="line"></div><div class="line"><span class="preprocessor">                            # Representation</span></div><div class="line">                            representation=Representation(</div><div class="line">                                # Initialize a population of integer-vector genomes</div><div class="line">                                initialize=create_real_vector(</div><div class="line">                                    bounds=[[0.0005, 0.5]] * num_genes)</div><div class="line">                            ),</div><div class="line"></div><div class="line"><span class="preprocessor">                            # Operator pipeline</span></div><div class="line">                            pipeline=[</div><div class="line">                                ops.tournament_selection(k=2),</div><div class="line">                                ops.clone,  # Copying individuals before we change them, just to be safe</div><div class="line">                                mutate_gaussian(<a class="code" href="namespacestd.html">std</a>=0.5, hard_bounds=[[0.0005, 0.5]]*num_genes,</div><div class="line">                                                expected_num_mutations=1),</div><div class="line">                                ops.pool(size=pop_size),</div><div class="line"><span class="preprocessor">                                # Here again, we use grouped_evaluate to send chunks of individuals to the ExternalProcessProblem.</span></div><div class="line">                                ops.grouped_evaluate(max_individuals_per_chunk=max_individuals_per_chunk),</div><div class="line"><span class="preprocessor">                                # Print fitness statistics to stdout at each genration</span></div><div class="line">                                probe.FitnessStatsCSVProbe(stream=sys.stdout)</div><div class="line">                            ] + (viz_probes <span class="keywordflow">if</span> plots <span class="keywordflow">else</span> [])</div><div class="line">                        )</div></div><!-- fragment --><p> Here we specify that the solutions of the probelm are represented as real numbers, and the parameter range is (0.0005, 0.5). We then define the operator pipeline, which performs selection, mutation, and evaluation in sequence.</p>
<p>To launch the LEAP parameter tuning process, we can use the following command: </p><div class="fragment"><div class="line">python3 leap_TuneFiringRates.py</div></div><!-- fragment --><p>Input genomes and fitness information will be printed out like this: </p><div class="fragment"><div class="line">Input: b<span class="stringliteral">&#39;0.0,0.0,0.1,0.1&#39;</span></div><div class="line">Simulation-stdout: b<span class="stringliteral">&#39;0.0333333\n&#39;</span></div><div class="line">Simulation-stderr: b<span class="stringliteral">&#39;&#39;</span></div><div class="line">Fitnesses: [0.0333333]</div></div><!-- fragment --><h1><a class="anchor" id="tut7s5_references"></a>
References</h1>
<p>Beyeler, M., Carlson, K. D., Chou, T. S., Dutt, N., Krichmar, J. L., <a class="el" href="classCARLsim.html" title="CARLsim User Interface This class provides a user interface to the public sections of CARLsimCore sou...">CARLsim</a> 3: A user-friendly and highly optimized library for the creation of neurobiologically detailed spiking neural networks. International Joint Confernece on Neural Networks (IJCNN), 2015.</p>
<p>Carlson, K. D., Nageswaran, J. M., Dutt, N., Krichmar, J. L., An efficient automated parameter tuning framework for spiking neural networks, Front. Neurosci., vol. 8, no. 10, 2014. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Jul 14 2022 18:14:01 for CARLsim by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
